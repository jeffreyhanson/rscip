% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scip_solve.R
\name{scip_solve}
\alias{scip_solve}
\title{Solve a mixed integer problem with \emph{SCIP}}
\usage{
scip_solve(
  obj,
  lb,
  ub,
  vtype,
  A,
  sense,
  rhs,
  modelsense = "max",
  gap = 0,
  threads = 1,
  presolve = TRUE,
  time_limit = 1e+20,
  first_feasible = FALSE,
  initial_solution = NULL,
  verbose = TRUE
)
}
\arguments{
\item{obj}{\code{numeric} vector of coefficients to specify the
objective function. Note that arguments should have one value per decision
variable (i.e., column in \code{A}).}

\item{lb}{\code{numeric} vector of lower bounds for decision
variables.
Note that arguments should have one value per decision variable
(i.e. column in \code{A}).}

\item{ub}{\code{numeric} vector of upper bounds for decision variables.
Note that arguments should have one value per decision variable
(i.e., column in \code{A}).}

\item{vtype}{\code{character} vector values that indicate the variable
types for each decision variable.
Available options include
\code{"B"} for binary variables,
\code{"C"} for continuous variables, and
\code{"I"} for integer variables.
Note that arguments should have one value per decision variable
(i.e., column in \code{A}).}

\item{A}{matrix (i.e. \code{matrix} or \code{\link{Matrix-class}}) of
constraint coefficients. Here, each column corresponds to a different
decision variable, and each row corresponds to a different constraint.
To improve performance, it is recommended to specify the matrix using
a sparse format (see \code{\link[Matrix]{sparseMatrix}}).}

\item{sense}{\code{character} vector indicating the sense values for the
constraints.
Available options include \code{">="}, \code{"<="} and \code{"="}.
Note that arguments should have one value per constraint
(i.e., row in \code{A}).}

\item{rhs}{\code{numeric} vector denoting the right-hand-side values sense for the
constraints.
Note that arguments should have one value per constraint
(i.e., row in \code{A}).}

\item{modelsense}{\code{character} value indicating the model sense.
Available options include \verb{"max}" to maximize the objective function,
or \code{"min"} to minimize the objective function.
Defaults to \code{"min"}.}

\item{gap}{\code{numeric} optimality gap.
For example, a value of 0.05 means that solutions must be within
5\% of optimality.
Defaults to 0 to produce optimal solutions.}

\item{threads}{\code{numeric} number of threads to use for optimization.
Defaults to 1.}

\item{presolve}{\code{logical} should presolve routines be applied to
before attempting to solve the problem?
Defaults to \code{TRUE}.}

\item{time_limit}{\code{numeric} maximum amount of time (seconds) permitted for
completing the optimization process.
Defaults to 1e+20.}

\item{first_feasible}{\code{logical} should the optimization process stop
after finding a feasible solution? This is useful for verifying the
feasibility of an optimization process. Note that if \code{TRUE}, then
the returned solution may not meet the optimality gap (per \code{gap}).
Defaults to \code{FALSE}.}

\item{initial_solution}{\code{numeric} initial values
for starting solution. Missing (\code{NA}) values can be used to indicate
that the starting value for a solution should be automatically calculated.
Defaults to \code{NULL} such that the starting solution is automatically
generated.}

\item{verbose}{\code{logical} should progress be displayed during optimization?
Defaults to \code{TRUE}.}
}
\value{
A \code{list} containing the solution and additional information.
Specifically, it contains the following elements:

\describe{

\item{x}{\code{numeric} values of the decision variables
in the solution.}

\item{objval}{\code{numeric} objective value of the solution.}

\item{status}{\code{character} description of the optimization process
when it finished. See the Solver Status section for more information.}

}
}
\description{
\href{https://www.scipopt.org/}{\emph{SCIP}}
(Solving Constraint Integer Programs)
is an open-source mixed integer programming
solver (Bestuzheva \emph{et al.} 2021).
By interfacing with the \emph{SCIP} solver, this function can be used to
generate optimal solutions to optimization problems.
}
\section{Solver Status}{

The status of the \emph{SCIP} solver indicates the stopping criteria for the
optimization process. This information can be helpful for interpreting
the solution. For example, if the status indicates that the stopping
criteria was due to a time limit, then this would suggest that the
solution does not meet the gap. Alternatively, if the status
indicates that the stopping criteria was due to the solver finding
an optimal solution, then this would indicate that the solution is optimal.
All the solver statuses are described below.
\describe{

\item{SCIP_STATUS_UNKNOWN}{
The solving status is not yet known.
}

\item{SCIP_STATUS_USERINTERRUPT}{
The user interrupted the solving process (by pressing CTRL-C).
}

\item{SCIP_STATUS_NODELIMIT}{
The solving process was interrupted because the node limit was reached.
}

\item{SCIP_STATUS_TOTALNODELIMIT}{
The solving process was interrupted because the total node limit was reached
(including restarts).
}

\item{SCIP_STATUS_STALLNODELIMIT}{
The solving process was interrupted because the stalling node limit was
reached (no improvement with regard to the primal bound).
}

\item{SCIP_STATUS_TIMELIMIT}{
The solving process was interrupted because the time limit was reached.
}

\item{SCIP_STATUS_MEMLIMIT}{
The solving process was interrupted because the memory limit was reached.
}

\item{SCIP_STATUS_GAPLIMIT}{
The solving process was interrupted because the gap limit was reached.
}

\item{SCIP_STATUS_SOLLIMIT}{
The solving process was interrupted because the solution limit was reached.
}

\item{SCIP_STATUS_BESTSOLLIMIT}{
The solving process was interrupted because the solution improvement limit
was reached.
}

\item{SCIP_STATUS_RESTARTLIMIT}{
The solving process was interrupted because the restart limit was reached.
}

\item{SCIP_STATUS_OPTIMAL}{
The problem was solved to optimality, an optimal solution is available.
}

\item{SCIP_STATUS_INFEASIBLE}{
The problem was proven to be infeasible.
}

\item{SCIP_STATUS_UNBOUNDED}{
The problem was proven to be unbounded.
}

\item{SCIP_STATUS_INFORUNBD}{
The problem was proven to be either infeasible or unbounded.
}

\item{SCIP_STATUS_TERMINATE}{
Status if the process received a SIGTERM signal.
}

}
}

\examples{
\dontrun{
# Mathematically define a mixed integer programming problem
## maximize:
##   1 * x + 2 * y + 0.5 * z (eqn 1a)
## subject to:
##   x + y <= 1              (eqn 1b)
##   3 * x + 4 * z >= 5      (eqn 1c)
##   z = 4                   (eqn 1d)
##  x <= 10                  (eqn 1e)
##  y <= 11                  (eqn 1f)
##  z <= 13                  (eqn 1g)
##  x, y, z is integer       (eqn 1h)

# Create variables to represent this problem
### define objective function (eqn 1a)
obj <- c(1, 2, 0.5)

## define constraint matrix (eqns 1c--1d)
A <- matrix(c(1, 1, 0, 3, 0, 4, 0, 0, 1), byrow = TRUE, nrow = 3)
print(A)

## note that we could also define the constraint matrix using a
## sparse format to reduce memory consumption
## (though not needed for such a small problem)
library(Matrix)
A_sp <- sparseMatrix(
  i = c(1, 2, 1, 2, 3),
  j = c(1, 1, 2, 3, 3),
  x = c(1, 3, 1, 4, 1))
print(A_sp)

## define sense for constraints (eqns 1c--1d)
sense <- c("<=", ">=", "=")

## define right-hand-side values for constraints (eqns 1c--1d)
rhs <- c(1, 5, 4)

## define upper and lower bounds for decision variables (eqns 1e--1g)
lb <- c(0, 0, 0)
ub <- c(10, 11, 13)

## specify decision variable types (eqn 1h)
vtype <- c("I", "I", "I")

# Generate solution
## run solver (with default settings)
result <- scip_solve(
  obj = obj, lb = lb, ub = ub, vtype = vtype,
  A = A, sense = sense, rhs = rhs,
  modelsense = "max"
)

## print result
print(result)

# Generate a solution with customized settings
## specify that only a single thread should be used,
## we only need a solution within 20\% of optimality,
## and that we can only spend 2 seconds for optimization

## run solver (with customized settings)
result2 <- scip_solve(
  obj = obj, lb = lb, ub = ub, vtype = vtype,
  A = A, sense = sense, rhs = rhs,
  modelsense = "max",
  gap = 0.2, threads = 1, time_limit = 2
)

## print result
## we can see that this result is exactly the same as the previous
## result, so these customized settings did not really any influence.
## this is because the optimization problem is incredibly simple
## and so SCIP can find the optimal solution pretty much instantly
## we would expect such customized settings to have an influence
## when solving more complex problems
print(result2)
}

}
\references{
Bestuzheva K., Besançon M., Chen W-K, Chmiela A., Donkiewicz T., van
Doornmalen J., Eifler L., Gaul O., Gamrath G., Gleixner A., Gottwald L.,
Graczyk C.,  Halbig K., Hoen A., Hojny C., van der Hulst R., Koch T.,
Lübbecke M., Maher S.J., Matter F., Mühmer E., Müller B., Pfetsch M.E.,
Rehfeldt D., Schlein S., Schlösser F., Serrano F., Shinano Y., Sofranac B.,
Turner M, Vigerske S.,  Wegscheider F., Wellner P., Weninger D., and
Witzig J. (2021) The SCIP Optimization Suite 8.0. Available at Optimization
Online and as ZIB-Report 21-41. \url{http://www.optimization-online.org/DB_HTML/2021/12/8728.html}
}
